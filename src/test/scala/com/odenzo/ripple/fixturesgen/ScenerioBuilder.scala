package com.odenzo.ripple.fixturesgen

import cats.implicits._
import com.typesafe.scalalogging.StrictLogging
import io.circe.{Decoder, JsonObject}
import io.circe.syntax._

import com.odenzo.ripple.integration_testkit.JsonReqRes
import com.odenzo.ripple.localops.utils.CirceUtils
import com.odenzo.ripple.localops.utils.caterrors.AppError
import com.odenzo.ripple.models.atoms.{AccountAddr, AccountKeys, BitMaskFlag, Drops, RippleSignature, SigningPublicKey, TxBlob, TxnSequence}
import com.odenzo.ripple.models.support.GenesisAccount
import com.odenzo.ripple.models.wireprotocol.accountinfo.{AccountInfoRq, AccountInfoRs, WalletProposeRq, WalletProposeRs}
import com.odenzo.ripple.models.wireprotocol.ledgerinfo.{LedgerAcceptRq, LedgerAcceptRs}
import com.odenzo.ripple.models.wireprotocol.transactions.transactiontypes.{CommonTx, PaymentTx}
import com.odenzo.ripple.models.wireprotocol.transactions.{SignRq, SignRs, SubmitRq, SubmitRs}

/**
  * Some helpers to create ripple test-net server scenario.
  * Use on local test-net, ideally be able to re-run each time.
  * This assumes a local docket normally, and sets up some base accounts.
  */
object ScenerioBuilder extends StrictLogging with FixtureGeneratorUtils {

  val genesis: AccountKeys = GenesisAccount.accountKeys

  /** Genesis is a secp account, this is MasterSeed */
  val genesisSecret: RippleSignature = genesis.secret

  val genesisAddr: AccountAddr = genesis.address

  /** Tick over ledger when it is in stand-alone mode */
  def advanceLedger(): Either[AppError, LedgerAcceptRs] = {
    val rs = doCmdCall(LedgerAcceptRq().asJsonObject, LedgerAcceptRs.decoder)
    rs
  }

  /**
  *    Note: This does not automatically advance the ledger when in stand-alone mode.
    * @param tx_json Transaction to sign and submit. Since server side auto-fillable ok but not recommended
    * @param sig
    * @return
    */
  def serverSignAndSubmit(tx_json:JsonObject, sig:AccountKeys): Either[AppError, SubmitRs] = {
    logger.info(s"Secret: $sig")
    for {
      sign ← serverSign(tx_json, sig)
      submit ← submitTxn(sign.tx_blob)
    } yield submit
  }

  def serverSign(tx_json:JsonObject, sig:AccountKeys ): Either[AppError, SignRs] = {
    val toSign = SignRq(tx_json.asJson, sig.master_seed,false,key_type=sig.key_type.v)
    val msgObj = CirceUtils.pruneNullFields(toSign.asJsonObject)
    logger.debug(s"Sending Sign CMD: \n ${msgObj.asJson.spaces4}")
    doCmdCall(msgObj, SignRs.decoder2)
  }

  /** Submits a fully signed transaction, represented as txblob */
  def submitTxn(txblob: TxBlob): Either[AppError, SubmitRs] = {
    val rq = SubmitRq(txblob, fail_hard = true)
    for {
      rr ← doCall(rq.asJsonObject)
      _ = logger.debug(s"RR: ${reqres2string(rr)}")
      rs ← decodeTxnCall(rr, Decoder[SubmitRs])
    } yield rs
  }

  /** Gets the latest account sequence for use in populating transactions */
  def getAccountSequence(address: AccountAddr): Either[AppError, TxnSequence] = {
    val rq                                   = AccountInfoRq(address, queue = false, signer_lists = false, strict = true)
    val ans: Either[AppError, AccountInfoRs] = doCmdCall(rq.asJsonObject, AccountInfoRs.decoder)
    ans.map { rs ⇒
      val s = rs.account_data.sequence
      logger.info(s"Account ${address} Sequence: $s")
       s
    }

  }

  /** Creates a new account using server side WalletPropose and then initial transfer of XRP from Genesis Account
    *
    * @param amount
    * @param keyType   secp256k1 or ed25519
    *
    * @return  The submission results for activating the new account, or Error.
    */
  def createNewAccount(amount: Drops, keyType: String): Either[AppError, SubmitRs] = {
    val walletRq = WalletProposeRq(key_type = Some(keyType))
    val result = for {
      walletRs  ← doCmdCall(walletRq.asJsonObject, WalletProposeRs.decoder)
      keys      = walletRs.keys
      seq       <- getAccountSequence(genesis.address)         // Not strictly necessary
      rq        = createXrpTransfer(genesis, keys.address, amount, seq)
      submitted ←  serverSignAndSubmit(rq.asJsonObject, genesis)
      _         <- advanceLedger()
    } yield submitted
    result.left.foreach(v => logger.error(s"ERROR Creating Account" + v.show))
    result
  }

  /**
    * Does a wallet propose with autogenerated random seed.
    *
    * @param numWallets Number of wallet proposes to do.
    * @param keytype    ed2519 or secp256k1 as of June 2019
    */
  def makeWallets(numWallets: Int, keytype: String): Either[AppError, List[(AccountKeys, JsonReqRes)]] = {
    (1 to numWallets).toList.traverse(_ ⇒ makeWallet(keytype))
  }

  def makeWallet(keytype: String = "ed25519"): Either[AppError, (AccountKeys, JsonReqRes)] = {
    val rq = WalletProposeRq(key_type = Some(keytype))
    doCmdCallKeepJson[WalletProposeRs](rq.asJsonObject, WalletProposeRs.decoder)
      .map { case (rs, rr) => (rs.keys, rr) }

  }

  /**
  *
    * @param from
    * @param to
    * @param amount
    * @param sequence Required even for server signed now unless offline = false
    *                 doing server side signing Noneok
    * @return
    */
  def createXrpTransfer(from: AccountKeys, to: AccountAddr, amount: Drops, sequence: TxnSequence): PaymentTx = {

    val common = CommonTx(
      sequence = Some(sequence),
      fee = Some(Drops.fromXrp("50")),
      signers = None,
      signingPubKey = Some(SigningPublicKey(from.public_key_hex)),
      flags = BitMaskFlag(2147483648L),
      memos = None,
      hash = None
    )

    PaymentTx(account = from.account_id,
              amount = amount,
              destination = to,
              invoiceID = None,
              paths = None,
              sendMax = None,
              deliverMin = None,
              base = common)

  }

}
